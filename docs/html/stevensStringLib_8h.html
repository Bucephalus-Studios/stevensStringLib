<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stevensStringLib: /home/jeff/stevensStringLib/stevensStringLib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">stevensStringLib<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">/home/jeff/stevensStringLib/stevensStringLib.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An easy-to-use C++ library with convenient functions for working with strings.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;locale&gt;</code><br />
<code>#include &lt;charconv&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
</div>
<p><a href="stevensStringLib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86fbb60ec5f626744264a2e0ab5066a9" id="r_a86fbb60ec5f626744264a2e0ab5066a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a86fbb60ec5f626744264a2e0ab5066a9">stevensStringLib::contains</a> (const std::string &amp;str, const std::string &amp;substring)</td></tr>
<tr class="separator:a86fbb60ec5f626744264a2e0ab5066a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75dd17730068a151f3f34d299cfb7fa" id="r_ae75dd17730068a151f3f34d299cfb7fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ae75dd17730068a151f3f34d299cfb7fa">stevensStringLib::separate</a> (const std::string &amp;str, const std::string &amp;separator=&quot;,&quot;, const bool &amp;omitEmptyStrings=true)</td></tr>
<tr class="separator:ae75dd17730068a151f3f34d299cfb7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105280ad458e2aeea94c59174c53ad82" id="r_a105280ad458e2aeea94c59174c53ad82"><td class="memItemLeft" align="right" valign="top"><a id="a105280ad458e2aeea94c59174c53ad82" name="a105280ad458e2aeea94c59174c53ad82"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stevensStringLib::sep</b> (const std::string &amp;str, const std::string &amp;separator=&quot;,&quot;, const bool &amp;omitEmptyStrings=true)</td></tr>
<tr class="memdesc:a105280ad458e2aeea94c59174c53ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="stevensStringLib_8h.html#ae75dd17730068a151f3f34d299cfb7fa">separate()</a> <br /></td></tr>
<tr class="separator:a105280ad458e2aeea94c59174c53ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1a2d1fc6655066097dcdca512de63f" id="r_a5c1a2d1fc6655066097dcdca512de63f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a5c1a2d1fc6655066097dcdca512de63f">stevensStringLib::cap1stChar</a> (std::string str)</td></tr>
<tr class="separator:a5c1a2d1fc6655066097dcdca512de63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1197f49a832b1beab045ad096c2758" id="r_a7c1197f49a832b1beab045ad096c2758"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a7c1197f49a832b1beab045ad096c2758">stevensStringLib::toUpper</a> (std::string &amp;str)</td></tr>
<tr class="separator:a7c1197f49a832b1beab045ad096c2758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734c980bfd536f7929cd051283ea192c" id="r_a734c980bfd536f7929cd051283ea192c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a734c980bfd536f7929cd051283ea192c">stevensStringLib::isInteger</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a734c980bfd536f7929cd051283ea192c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ee6720d9d0028eb7891e9360b6c68a" id="r_a31ee6720d9d0028eb7891e9360b6c68a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a31ee6720d9d0028eb7891e9360b6c68a">stevensStringLib::isFloat</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a31ee6720d9d0028eb7891e9360b6c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72692e6b9776275f737e5087ee1b87cb" id="r_a72692e6b9776275f737e5087ee1b87cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a72692e6b9776275f737e5087ee1b87cb">stevensStringLib::isNumber</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a72692e6b9776275f737e5087ee1b87cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac323930776f40cf61fcfd1bbc5128ded" id="r_ac323930776f40cf61fcfd1bbc5128ded"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac323930776f40cf61fcfd1bbc5128ded">stevensStringLib::string_to_bool</a> (std::string &amp;str)</td></tr>
<tr class="separator:ac323930776f40cf61fcfd1bbc5128ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34011fafa3843edec6ee27c5ad6dcf95" id="r_a34011fafa3843edec6ee27c5ad6dcf95"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a34011fafa3843edec6ee27c5ad6dcf95">stevensStringLib::bool_to_string</a> (const bool &amp;input)</td></tr>
<tr class="separator:a34011fafa3843edec6ee27c5ad6dcf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44b873d3a3ae1687e1f6641aab5ae99" id="r_aa44b873d3a3ae1687e1f6641aab5ae99"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aa44b873d3a3ae1687e1f6641aab5ae99">stevensStringLib::trim</a> (const std::string &amp;str, const int &amp;charsToTrim)</td></tr>
<tr class="separator:aa44b873d3a3ae1687e1f6641aab5ae99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc289dc431709640aac960c1322f4278" id="r_acc289dc431709640aac960c1322f4278"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#acc289dc431709640aac960c1322f4278">stevensStringLib::removeWhitespace</a> (std::string str)</td></tr>
<tr class="separator:acc289dc431709640aac960c1322f4278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b34e30265e4aded341b65c49399919" id="r_a89b34e30265e4aded341b65c49399919"><td class="memTemplParams" colspan="2"><a id="a89b34e30265e4aded341b65c49399919" name="a89b34e30265e4aded341b65c49399919"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89b34e30265e4aded341b65c49399919"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stevensStringLib::mapifyStringHelper</b> (T map, std::string str, std::string keyValueSeparator, std::string pairSeparator, bool ignoreWhitespace=true)</td></tr>
<tr class="memdesc:a89b34e30265e4aded341b65c49399919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the work for mapifyString and unordered_mapifyString. <br /></td></tr>
<tr class="separator:a89b34e30265e4aded341b65c49399919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3c2bc3c3c819fbc8d8e8de6a3d8423" id="r_a2c3c2bc3c3c819fbc8d8e8de6a3d8423"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a2c3c2bc3c3c819fbc8d8e8de6a3d8423">stevensStringLib::mapifyString</a> (std::string str, std::string keyValueSeparator, std::string pairSeparator, bool ignoreWhitespace=true)</td></tr>
<tr class="separator:a2c3c2bc3c3c819fbc8d8e8de6a3d8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400139dff51fd0cad31ad2f0fcbc1274" id="r_a400139dff51fd0cad31ad2f0fcbc1274"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a400139dff51fd0cad31ad2f0fcbc1274">stevensStringLib::unordered_mapifyString</a> (std::string str, std::string keyValueSeparator=&quot;:&quot;, std::string pairSeparator=&quot;,&quot;, bool ignoreWhitespace=true)</td></tr>
<tr class="separator:a400139dff51fd0cad31ad2f0fcbc1274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e773702461601b8650db910645916e" id="r_a21e773702461601b8650db910645916e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21e773702461601b8650db910645916e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a21e773702461601b8650db910645916e">stevensStringLib::stringifyMap</a> (T map, std::string keyValueSeparator=&quot;:&quot;, std::string pairSeparator=&quot;,&quot;)</td></tr>
<tr class="separator:a21e773702461601b8650db910645916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5ecb7f12940ba9db9f0633717c6304" id="r_aec5ecb7f12940ba9db9f0633717c6304"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aec5ecb7f12940ba9db9f0633717c6304">stevensStringLib::countLines</a> (std::string str)</td></tr>
<tr class="separator:aec5ecb7f12940ba9db9f0633717c6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af737e054dda2d8cc062e45c288304b6e" id="r_af737e054dda2d8cc062e45c288304b6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#af737e054dda2d8cc062e45c288304b6e">stevensStringLib::countFileLines</a> (const std::string &amp;filePath)</td></tr>
<tr class="separator:af737e054dda2d8cc062e45c288304b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383ce9fb993729b272b68f339add44b1" id="r_a383ce9fb993729b272b68f339add44b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a383ce9fb993729b272b68f339add44b1">stevensStringLib::wrapToWidth</a> (std::string str, int wrapWidth)</td></tr>
<tr class="separator:a383ce9fb993729b272b68f339add44b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef46b03fd4e57d73392c25dfd2b580f0" id="r_aef46b03fd4e57d73392c25dfd2b580f0"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aef46b03fd4e57d73392c25dfd2b580f0">stevensStringLib::circularIndex</a> (std::string str, int i)</td></tr>
<tr class="separator:aef46b03fd4e57d73392c25dfd2b580f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7979bb34ee40190b84d9750f5a8c94" id="r_a7c7979bb34ee40190b84d9750f5a8c94"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a7c7979bb34ee40190b84d9750f5a8c94">stevensStringLib::eraseCharsFromEnd</a> (std::string str, int n)</td></tr>
<tr class="separator:a7c7979bb34ee40190b84d9750f5a8c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97f9b043053f16df01be3344e15ba1" id="r_aaa97f9b043053f16df01be3344e15ba1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aaa97f9b043053f16df01be3344e15ba1">stevensStringLib::findAll</a> (std::string str, std::string substr)</td></tr>
<tr class="separator:aaa97f9b043053f16df01be3344e15ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc5f9915fcdea95ccd3536d77964b" id="r_a5bbbc5f9915fcdea95ccd3536d77964b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a5bbbc5f9915fcdea95ccd3536d77964b">stevensStringLib::getWhitespaceString</a> (const std::locale &amp;loc)</td></tr>
<tr class="separator:a5bbbc5f9915fcdea95ccd3536d77964b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78a2a94e837596ce18dfb92282b0ea5" id="r_aa78a2a94e837596ce18dfb92282b0ea5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aa78a2a94e837596ce18dfb92282b0ea5">stevensStringLib::trimWhitespace</a> (std::string str)</td></tr>
<tr class="separator:aa78a2a94e837596ce18dfb92282b0ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9031d37220df1c65182f588a9e1e998c" id="r_a9031d37220df1c65182f588a9e1e998c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a9031d37220df1c65182f588a9e1e998c">stevensStringLib::char_to_string</a> (const char &amp;c)</td></tr>
<tr class="separator:a9031d37220df1c65182f588a9e1e998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc5a8eb271c99ac169ef509a7faeecb" id="r_a9fc5a8eb271c99ac169ef509a7faeecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a9fc5a8eb271c99ac169ef509a7faeecb">stevensStringLib::isNotDigit</a> (const char &amp;c)</td></tr>
<tr class="separator:a9fc5a8eb271c99ac169ef509a7faeecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac70294354fd548c0fcc74c31f3b924" id="r_aaac70294354fd548c0fcc74c31f3b924"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aaac70294354fd548c0fcc74c31f3b924">stevensStringLib::eraseNonNumericChars</a> (std::string str)</td></tr>
<tr class="separator:aaac70294354fd548c0fcc74c31f3b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69119030f08c04d17f5ec4c59c0a8b6" id="r_ac69119030f08c04d17f5ec4c59c0a8b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac69119030f08c04d17f5ec4c59c0a8b6">stevensStringLib::reverse</a> (std::string str)</td></tr>
<tr class="separator:ac69119030f08c04d17f5ec4c59c0a8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc7a7ba1770dbc595aa351f8137bb4e" id="r_a3dc7a7ba1770dbc595aa351f8137bb4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a3dc7a7ba1770dbc595aa351f8137bb4e">stevensStringLib::isPalindrome</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a3dc7a7ba1770dbc595aa351f8137bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An easy-to-use C++ library with convenient functions for working with strings. </p>
<dl class="section author"><dt>Author</dt><dd>Jeff Stevens (<a href="#" onclick="location.href='mai'+'lto:'+'jef'+'f@'+'buc'+'ep'+'hal'+'us'+'stu'+'di'+'os.'+'co'+'m'; return false;">jeff@<span class="obfuscator">.nosp@m.</span>buce<span class="obfuscator">.nosp@m.</span>phalu<span class="obfuscator">.nosp@m.</span>sstu<span class="obfuscator">.nosp@m.</span>dios.<span class="obfuscator">.nosp@m.</span>com</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.1 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023-12-21 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) Bucephalus Studios 2023</dd></dl>
<p>Created and released under the MIT license. See the LICENSE file in the repository folder.</p>
<p>If you'd like to buy me a coffee or send me a tip for my work on this library, you can do that here: <a href="https://ko-fi.com/bucephalus_studios">https://ko-fi.com/bucephalus_studios</a></p>
<p>Thank you very, very much for being interested in my code! Hope it serves you well &lt;3 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a34011fafa3843edec6ee27c5ad6dcf95" name="a34011fafa3843edec6ee27c5ad6dcf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34011fafa3843edec6ee27c5ad6dcf95">&#9670;&#160;</a></span>bool_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::bool_to_string </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a boolean value to a string value.</p>
<p>Taken from OJ's answer here: <a href="https://stackoverflow.com/questions/29383/converting-bool-to-text-in-c">https://stackoverflow.com/questions/29383/converting-bool-to-text-in-c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>- The boolean value we wish to convert to a string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The boolean value represented as a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c1a2d1fc6655066097dcdca512de63f" name="a5c1a2d1fc6655066097dcdca512de63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1a2d1fc6655066097dcdca512de63f">&#9670;&#160;</a></span>cap1stChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::cap1stChar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string with the first letter capitalized. If the string is empty, then we just return the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we want to capitalize the first letter of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The string str with the first letter capitalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9031d37220df1c65182f588a9e1e998c" name="a9031d37220df1c65182f588a9e1e998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9031d37220df1c65182f588a9e1e998c">&#9670;&#160;</a></span>char_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::char_to_string </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a character c, convert it to a std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- The character we'd like to convert to a string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A string representing the character c. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef46b03fd4e57d73392c25dfd2b580f0" name="aef46b03fd4e57d73392c25dfd2b580f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef46b03fd4e57d73392c25dfd2b580f0">&#9670;&#160;</a></span>circularIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char stevensStringLib::circularIndex </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string an an integer representing an index, return a single character from the string by the process of circular indexing.</p>
<p>Circular indexing is performed by indexing over the string from left to right. Once the index exceeds the length of the string, we begin indexing again from the lefthand side of the string and repeat the process until we stop at the final index. We return the character at that final index.</p>
<p>Example: circularIndex("Hello world!", 13) returns 'e', as we loop around to 'H' at 12 and index one space further to reach 'e'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are circularly indexing through. </td></tr>
    <tr><td class="paramname">i</td><td>- The index of the string to circularly index to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">char</td><td>- A character found in str that has been circularly indexed to at position i</td></tr>
  </table>
  </dd>
</dl>
<p>TODO: Create aliases ci and circ_i </p>

</div>
</div>
<a id="a86fbb60ec5f626744264a2e0ab5066a9" name="a86fbb60ec5f626744264a2e0ab5066a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fbb60ec5f626744264a2e0ab5066a9">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, determine whether it has an occurrence of the substring somewhere within it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are examining to see if it contains the substring. </td></tr>
    <tr><td class="paramname">substring</td><td>- The substring we are trying to see if it is contained in str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- Boolean indicating that input string contains the substring (true) or not (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af737e054dda2d8cc062e45c288304b6e" name="af737e054dda2d8cc062e45c288304b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af737e054dda2d8cc062e45c288304b6e">&#9670;&#160;</a></span>countFileLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stevensStringLib::countFileLines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the path to a file, count how many lines are in the file and return the integer count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>- The path to the file we want to count the number of lines of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>- The integer number of lines that the file contains. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec5ecb7f12940ba9db9f0633717c6304" name="aec5ecb7f12940ba9db9f0633717c6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5ecb7f12940ba9db9f0633717c6304">&#9670;&#160;</a></span>countLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stevensStringLib::countLines </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, count how many lines are in that string and return the integer count.</p>
<p>Solution from: <a href="https://stackoverflow.com/questions/3482064/counting-the-number-of-lines-in-a-text-file">https://stackoverflow.com/questions/3482064/counting-the-number-of-lines-in-a-text-file</a></p>
<p>TODO: Concerned with line counting problems presented here: <a href="https://stackoverflow.com/a/843484/16511184">https://stackoverflow.com/a/843484/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string which we wish to count the number of lines of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>- The integer count of the number of lines that the string str has. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c7979bb34ee40190b84d9750f5a8c94" name="a7c7979bb34ee40190b84d9750f5a8c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7979bb34ee40190b84d9750f5a8c94">&#9670;&#160;</a></span>eraseCharsFromEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseCharsFromEnd </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string str, erase the last n characters of the string.</p>
<p>Taken from: <a href="https://thispointer.com/remove-last-n-characters-from-a-string-in-c/">https://thispointer.com/remove-last-n-characters-from-a-string-in-c/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we want to erase characters from the end of. </td></tr>
    <tr><td class="paramname">n</td><td>- The number of characters we want to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The string str having n characters erased from the end of it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaac70294354fd548c0fcc74c31f3b924" name="aaac70294354fd548c0fcc74c31f3b924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac70294354fd548c0fcc74c31f3b924">&#9670;&#160;</a></span>eraseNonNumericChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseNonNumericChars </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases all non-numeric characters from a string and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string to release all non-numeric chars from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The string parameter we passed in, but all of its non-numeric characters removed from it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa97f9b043053f16df01be3344e15ba1" name="aaa97f9b043053f16df01be3344e15ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97f9b043053f16df01be3344e15ba1">&#9670;&#160;</a></span>findAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; stevensStringLib::findAll </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string str, find all occurrences of a substring within it. Returns a vector of all of the indices that the substring occurs at within the string str.</p>
<p>Based off of: <a href="https://stackoverflow.com/a/4034809">https://stackoverflow.com/a/4034809</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are searching for the substring in. </td></tr>
    <tr><td class="paramname">substr</td><td>- The substring we are looking for within string str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::vector&lt;size_t&gt;</td><td>- A vector containing all indices in increasing order that the substr occurs at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bbbc5f9915fcdea95ccd3536d77964b" name="a5bbbc5f9915fcdea95ccd3536d77964b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbc5f9915fcdea95ccd3536d77964b">&#9670;&#160;</a></span>getWhitespaceString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::getWhitespaceString </td>
          <td>(</td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a locale, return all of the whitespace characters for that locale in a string.</p>
<p>Credit: <a href="https://stackoverflow.com/a/36311304/16511184">https://stackoverflow.com/a/36311304/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>- The locale which we want to obtain a string of all whitespace characters for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A string of all whitespace characters defined in the given locale. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ee6720d9d0028eb7891e9360b6c68a" name="a31ee6720d9d0028eb7891e9360b6c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ee6720d9d0028eb7891e9360b6c68a">&#9670;&#160;</a></span>isFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects if a string is in the form of a valid c++ floating point number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we are checking to see if it represents a floating point number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if the string str represents a floating point number. False otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a734c980bfd536f7929cd051283ea192c" name="a734c980bfd536f7929cd051283ea192c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734c980bfd536f7929cd051283ea192c">&#9670;&#160;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isInteger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects if a string is in the form of a valid C++ integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we are checking to see if it represents an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if the string str represents an integer, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fc5a8eb271c99ac169ef509a7faeecb" name="a9fc5a8eb271c99ac169ef509a7faeecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc5a8eb271c99ac169ef509a7faeecb">&#9670;&#160;</a></span>isNotDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isNotDigit </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predicate function for eraseNonNumericChars. It performs a logical not operation on the result of the isdigit() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- The character we'd like to check to see if it is not a digit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if c is not a digit, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72692e6b9776275f737e5087ee1b87cb" name="a72692e6b9776275f737e5087ee1b87cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72692e6b9776275f737e5087ee1b87cb">&#9670;&#160;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects whether or not the user input is in the form of an integer or floating point number. Does not work for mathematical expressions!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking to see if it represents a number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if the string represents a number. False if otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dc7a7ba1770dbc595aa351f8137bb4e" name="a3dc7a7ba1770dbc595aa351f8137bb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc7a7ba1770dbc595aa351f8137bb4e">&#9670;&#160;</a></span>isPalindrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isPalindrome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if a std::string is a palindrime or not (the reversed order of characters equals the original order of characters). Note well that character case, spacing, and punctuation present in classic English palindromes like "A man, a plan, a canal, panama" prevent them from being valid C++ palindromes with this function, as the reverse order of this exact string is "amanap ,lanac a ,nalp a ,nam A" is not equivalent to the original order of characters.</p>
<p>Credit: <a href="https://stackoverflow.com/a/8362657/16511184">https://stackoverflow.com/a/8362657/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if str is a palindrome, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3c2bc3c3c819fbc8d8e8de6a3d8423" name="a2c3c2bc3c3c819fbc8d8e8de6a3d8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3c2bc3c3c819fbc8d8e8de6a3d8423">&#9670;&#160;</a></span>mapifyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; stevensStringLib::mapifyString </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pairSeparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreWhitespace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Problem!!! Data could potentially contain separator strings. We need to prevent this, possibly by requiring JSON formatting?</p>
<p>Given an input string str that can represent a map&lt;std::string,std::string, take two separator strings and separate the pairs from eachother, and the keys and values from each other. Then insert each key value pair into a std::map&lt;std::string,std::string&gt; object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to convert into a map&lt;std::string,std::string&gt;. </td></tr>
    <tr><td class="paramname">keyValueSeparator</td><td>- The string in str using to separate keys from values. </td></tr>
    <tr><td class="paramname">pairSeparator</td><td>- The string in str we are using separate pairs. </td></tr>
    <tr><td class="paramname">ignoreWhitespace</td><td>- Bool indicating if we should remove any whitespace from str before creating the map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">T&lt;std::string,std::string&gt;</td><td>- A map object of string-string key-value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc289dc431709640aac960c1322f4278" name="acc289dc431709640aac960c1322f4278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc289dc431709640aac960c1322f4278">&#9670;&#160;</a></span>removeWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::removeWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all tabs, spaces, newlines, and anything else from a string that is defined as whitespace in the current locale.</p>
<p>Learn what is defined as whitespace: <a href="https://en.cppreference.com/w/cpp/string/byte/isspace">https://en.cppreference.com/w/cpp/string/byte/isspace</a> Credit to Michael Steller: <a href="https://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c">https://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string from which we wish to remove all the whitespace from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The input string but with all of the whitespace removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac69119030f08c04d17f5ec4c59c0a8b6" name="ac69119030f08c04d17f5ec4c59c0a8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69119030f08c04d17f5ec4c59c0a8b6">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::reverse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverses the order of a string's characters using std::reverse().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The reversed string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae75dd17730068a151f3f34d299cfb7fa" name="ae75dd17730068a151f3f34d299cfb7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75dd17730068a151f3f34d299cfb7fa">&#9670;&#160;</a></span>separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; stevensStringLib::separate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>omitEmptyStrings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Separates a string by a separator substring. Returns a vector of strings that were separated by the separator substring.</p>
<p>Example:</p>
<p>std::vector&lt;std::string&gt; result = separate( "John,Gina,Sebastian,Nick", ",")</p>
<p>//Value of result is: {"John","Gina","Sebastian","Nick"}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we intend to separate with this function. </td></tr>
    <tr><td class="paramname">separator</td><td>- The substring of str we intend to separate it by. </td></tr>
    <tr><td class="paramname">omitEmptyStrings</td><td>- If true, do not include empty strings in the returned vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">vector&lt;std::string&gt;</td><td>- A vector of substrings of the original string that have been split up by all occurrences of the separator parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac323930776f40cf61fcfd1bbc5128ded" name="ac323930776f40cf61fcfd1bbc5128ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac323930776f40cf61fcfd1bbc5128ded">&#9670;&#160;</a></span>string_to_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::string_to_bool </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a string and checks to see if it is a representation of the word "true" or "0". In those cases, return a true bool. In all other cases, return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we are converting to a bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if str is a form of the word true or 0, and false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21e773702461601b8650db910645916e" name="a21e773702461601b8650db910645916e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e773702461601b8650db910645916e">&#9670;&#160;</a></span>stringifyMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::stringifyMap </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an map or unordered_map of strings, turn it into a string of keys and values paired together, separated by delimiting characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>- Th map or unordered_map with string keys and values which we intend to turn into a string. </td></tr>
    <tr><td class="paramname">keyValueSeparator</td><td>- The string that separates keys from their values in the returned string. </td></tr>
    <tr><td class="paramname">pairSeparator</td><td>- The string that separates key-value pairs in the returned string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The all contents of the unordered map turned into a string list of separated key-value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c1197f49a832b1beab045ad096c2758" name="a7c1197f49a832b1beab045ad096c2758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1197f49a832b1beab045ad096c2758">&#9670;&#160;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::toUpper </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string with all characters in uppercase if possible.</p>
<p>Credit to this article: <a href="https://www.geeksforgeeks.org/conversion-whole-string-uppercase-lowercase-using-stl-c/">https://www.geeksforgeeks.org/conversion-whole-string-uppercase-lowercase-using-stl-c/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to make all uppercase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">string</td><td>- The parameter str, but all in uppercase!</td></tr>
  </table>
  </dd>
</dl>
<p>` </p>

</div>
</div>
<a id="aa44b873d3a3ae1687e1f6641aab5ae99" name="aa44b873d3a3ae1687e1f6641aab5ae99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44b873d3a3ae1687e1f6641aab5ae99">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>charsToTrim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string and integer X, erase (trim) X characters from both the beginning and end of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we would like to trim the characters from. </td></tr>
    <tr><td class="paramname">charsToTrim</td><td>- The number of characters to trim from the beginning and end of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A modified version of the string str, with a number characters from both the beginning and end of the string trimmed off equal to charsToTrim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa78a2a94e837596ce18dfb92282b0ea5" name="aa78a2a94e837596ce18dfb92282b0ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78a2a94e837596ce18dfb92282b0ea5">&#9670;&#160;</a></span>trimWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::trimWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all leading and trailing whitespace from a string (spaces, tabs, newlines, etc.), then return it.</p>
<p>Based on: <a href="https://stackoverflow.com/a/1798170">https://stackoverflow.com/a/1798170</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string to remove all of the leading and trailing whitespaces from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- str modified by removing all of its leading and trailing whitespaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a400139dff51fd0cad31ad2f0fcbc1274" name="a400139dff51fd0cad31ad2f0fcbc1274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400139dff51fd0cad31ad2f0fcbc1274">&#9670;&#160;</a></span>unordered_mapifyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::string &gt; stevensStringLib::unordered_mapifyString </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreWhitespace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of mapifyString that works for std::unordered_maps </p>

</div>
</div>
<a id="a383ce9fb993729b272b68f339add44b1" name="a383ce9fb993729b272b68f339add44b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383ce9fb993729b272b68f339add44b1">&#9670;&#160;</a></span>wrapToWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::wrapToWidth </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrapWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string and integer describing the total number of characters that can exist in a line of text, wrap the text by adding newlines between words so it may fit within a certain width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string which we wish to wrap to a certain width. </td></tr>
    <tr><td class="paramname">wrapWidth</td><td>- The width in number of characters we wish to wrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A modified version of the parameter str, with newlines added to it so that it fits within a certain character width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
