<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stevensStringLib: /home/jeff/stevensStringLib/stevensStringLib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">stevensStringLib<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">An easy-to-use C++ library with convenient functions for working with strings</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">/home/jeff/stevensStringLib/stevensStringLib.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An easy-to-use C++ library with convenient functions for working with strings.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;string_view&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;locale&gt;</code><br />
<code>#include &lt;charconv&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
</div>
<p><a href="stevensStringLib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af83dd4ced359aa4728438f8e469e6f2e" id="r_af83dd4ced359aa4728438f8e469e6f2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#af83dd4ced359aa4728438f8e469e6f2e">stevensStringLib::contains</a> (const std::string_view &amp;str, const std::string_view &amp;substring)</td></tr>
<tr class="separator:af83dd4ced359aa4728438f8e469e6f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee6af848c3910d695c0c191dd182c7d" id="r_aaee6af848c3910d695c0c191dd182c7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aaee6af848c3910d695c0c191dd182c7d">stevensStringLib::contains</a> (const std::string_view &amp;str, const char ch)</td></tr>
<tr class="separator:aaee6af848c3910d695c0c191dd182c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ffddbdb3678e6b288f2950cc9bce27" id="r_a32ffddbdb3678e6b288f2950cc9bce27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a32ffddbdb3678e6b288f2950cc9bce27">stevensStringLib::containsOnly</a> (const std::string_view &amp;str, const std::string_view &amp;chars)</td></tr>
<tr class="memdesc:a32ffddbdb3678e6b288f2950cc9bce27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string, determine if it contains only the characters in the given string.  <br /></td></tr>
<tr class="separator:a32ffddbdb3678e6b288f2950cc9bce27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dfd6d4329ab7bf69fb1cfd475508c7" id="r_ad3dfd6d4329ab7bf69fb1cfd475508c7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ad3dfd6d4329ab7bf69fb1cfd475508c7">stevensStringLib::eraseCharsFromEnd</a> (std::string str, size_t n)</td></tr>
<tr class="separator:ad3dfd6d4329ab7bf69fb1cfd475508c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b92ac54e4eb76eb32d7fd7ccd0f8de3" id="r_a9b92ac54e4eb76eb32d7fd7ccd0f8de3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a9b92ac54e4eb76eb32d7fd7ccd0f8de3">stevensStringLib::eraseCharsFromStart</a> (std::string str, size_t n)</td></tr>
<tr class="memdesc:a9b92ac54e4eb76eb32d7fd7ccd0f8de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string str, erase the first n characters of the string.  <br /></td></tr>
<tr class="separator:a9b92ac54e4eb76eb32d7fd7ccd0f8de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608c79000fd38c904b100d5cf9120299" id="r_a608c79000fd38c904b100d5cf9120299"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a608c79000fd38c904b100d5cf9120299">stevensStringLib::startsWith</a> (const std::string_view &amp;str, const std::string_view &amp;substr)</td></tr>
<tr class="memdesc:a608c79000fd38c904b100d5cf9120299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a string to see if it begins with a substring.  <br /></td></tr>
<tr class="separator:a608c79000fd38c904b100d5cf9120299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb69a84e86b3cd194600e38aff7c2f19" id="r_acb69a84e86b3cd194600e38aff7c2f19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#acb69a84e86b3cd194600e38aff7c2f19">stevensStringLib::endsWith</a> (const std::string_view &amp;str, const std::string_view &amp;substr)</td></tr>
<tr class="memdesc:acb69a84e86b3cd194600e38aff7c2f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a string to see if it ends with a substring.  <br /></td></tr>
<tr class="separator:acb69a84e86b3cd194600e38aff7c2f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcbc19ce3501fa3e06635657c2ded45" id="r_a4bcbc19ce3501fa3e06635657c2ded45"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a4bcbc19ce3501fa3e06635657c2ded45">stevensStringLib::findAll</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="separator:a4bcbc19ce3501fa3e06635657c2ded45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5eea65943a19263c1a018dda78fe81" id="r_aba5eea65943a19263c1a018dda78fe81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aba5eea65943a19263c1a018dda78fe81">stevensStringLib::findAll</a> (const std::string &amp;str, const char ch)</td></tr>
<tr class="separator:aba5eea65943a19263c1a018dda78fe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b29b2661c1430ffbac04f0e8a0876a3" id="r_a1b29b2661c1430ffbac04f0e8a0876a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a1b29b2661c1430ffbac04f0e8a0876a3">stevensStringLib::separate</a> (const std::string_view &amp;str, const char separator=',', const bool omitEmptyStrings=true)</td></tr>
<tr class="separator:a1b29b2661c1430ffbac04f0e8a0876a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7fd2ec486153c3481c1137155c0980" id="r_aff7fd2ec486153c3481c1137155c0980"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aff7fd2ec486153c3481c1137155c0980">stevensStringLib::separate</a> (const std::string_view &amp;str, const std::string_view &amp;separator, const bool omitEmptyStrings=true)</td></tr>
<tr class="separator:aff7fd2ec486153c3481c1137155c0980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a06dfefa8e30a9e16391ac301f0954a" id="r_a0a06dfefa8e30a9e16391ac301f0954a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a0a06dfefa8e30a9e16391ac301f0954a">stevensStringLib::join</a> (const std::vector&lt; std::string &gt; &amp;vec, const std::string &amp;separator, const bool omitEmptyStrings=true)</td></tr>
<tr class="memdesc:a0a06dfefa8e30a9e16391ac301f0954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of strings, concatenate them all into a single string, separating each string element in the final returned string by a given separator string.  <br /></td></tr>
<tr class="separator:a0a06dfefa8e30a9e16391ac301f0954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1a2d1fc6655066097dcdca512de63f" id="r_a5c1a2d1fc6655066097dcdca512de63f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a5c1a2d1fc6655066097dcdca512de63f">stevensStringLib::cap1stChar</a> (std::string str)</td></tr>
<tr class="separator:a5c1a2d1fc6655066097dcdca512de63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0bf954dd6582f3d6d8781f079689f2" id="r_a9c0bf954dd6582f3d6d8781f079689f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a9c0bf954dd6582f3d6d8781f079689f2">stevensStringLib::toUpper</a> (std::string str)</td></tr>
<tr class="separator:a9c0bf954dd6582f3d6d8781f079689f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd42f6dfa6de31b27f58781c57a7762e" id="r_acd42f6dfa6de31b27f58781c57a7762e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#acd42f6dfa6de31b27f58781c57a7762e">stevensStringLib::toLower</a> (std::string str)</td></tr>
<tr class="separator:acd42f6dfa6de31b27f58781c57a7762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eccf0d2f3d7970fc342f4c2faac274a" id="r_a8eccf0d2f3d7970fc342f4c2faac274a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a8eccf0d2f3d7970fc342f4c2faac274a">stevensStringLib::isInteger</a> (const std::string_view &amp;str)</td></tr>
<tr class="separator:a8eccf0d2f3d7970fc342f4c2faac274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ee6720d9d0028eb7891e9360b6c68a" id="r_a31ee6720d9d0028eb7891e9360b6c68a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a31ee6720d9d0028eb7891e9360b6c68a">stevensStringLib::isFloat</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a31ee6720d9d0028eb7891e9360b6c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf228e15ecf74d3127799a6d28b014a8" id="r_abf228e15ecf74d3127799a6d28b014a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#abf228e15ecf74d3127799a6d28b014a8">stevensStringLib::isStandardNumber</a> (const std::string_view &amp;str)</td></tr>
<tr class="memdesc:abf228e15ecf74d3127799a6d28b014a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string, check to see if it represents a number in standard notation.  <br /></td></tr>
<tr class="separator:abf228e15ecf74d3127799a6d28b014a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff84548f35ed049a4cba5ac01fdf4a6" id="r_a5ff84548f35ed049a4cba5ac01fdf4a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a5ff84548f35ed049a4cba5ac01fdf4a6">stevensStringLib::isScientificNumber</a> (const std::string_view &amp;str)</td></tr>
<tr class="memdesc:a5ff84548f35ed049a4cba5ac01fdf4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string, check to see if it represents a number in scientific notation.  <br /></td></tr>
<tr class="separator:a5ff84548f35ed049a4cba5ac01fdf4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac011598c8d05818536e48fd96ca2b12d" id="r_ac011598c8d05818536e48fd96ca2b12d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac011598c8d05818536e48fd96ca2b12d">stevensStringLib::isNumber</a> (const std::string_view &amp;str)</td></tr>
<tr class="separator:ac011598c8d05818536e48fd96ca2b12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cee1aced824a0f8ee615dbf7035478" id="r_a66cee1aced824a0f8ee615dbf7035478"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a66cee1aced824a0f8ee615dbf7035478">stevensStringLib::stringToBool</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a66cee1aced824a0f8ee615dbf7035478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92dec2b0a512e7141df8aa6dd63c86f" id="r_ac92dec2b0a512e7141df8aa6dd63c86f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac92dec2b0a512e7141df8aa6dd63c86f">stevensStringLib::boolToString</a> (const bool input)</td></tr>
<tr class="separator:ac92dec2b0a512e7141df8aa6dd63c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d846cb4529597c7fd190c026892ff6d" id="r_a5d846cb4529597c7fd190c026892ff6d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a5d846cb4529597c7fd190c026892ff6d">stevensStringLib::trim</a> (const std::string &amp;str, const unsigned int charsToTrim)</td></tr>
<tr class="separator:a5d846cb4529597c7fd190c026892ff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc289dc431709640aac960c1322f4278" id="r_acc289dc431709640aac960c1322f4278"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#acc289dc431709640aac960c1322f4278">stevensStringLib::removeWhitespace</a> (std::string str)</td></tr>
<tr class="separator:acc289dc431709640aac960c1322f4278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412f31d61fe4c1f5158e878100267638" id="r_a412f31d61fe4c1f5158e878100267638"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a412f31d61fe4c1f5158e878100267638"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a412f31d61fe4c1f5158e878100267638">stevensStringLib::mapifyStringHelper</a> (T &amp;map, const std::string_view &amp;str, const std::string_view &amp;keyValueSeparator, const std::string_view &amp;pairSeparator)</td></tr>
<tr class="memdesc:a412f31d61fe4c1f5158e878100267638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the work step for mapifyString and unordered_mapifyString.  <br /></td></tr>
<tr class="separator:a412f31d61fe4c1f5158e878100267638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a3b051465b829d63a0c0867193f4cb" id="r_a93a3b051465b829d63a0c0867193f4cb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a93a3b051465b829d63a0c0867193f4cb">stevensStringLib::mapifyString</a> (const std::string_view &amp;str, const std::string_view &amp;keyValueSeparator=&quot;:&quot;, const std::string_view &amp;pairSeparator=&quot;,&quot;)</td></tr>
<tr class="separator:a93a3b051465b829d63a0c0867193f4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9087ef54deb687c501000f3516de6" id="r_af0e9087ef54deb687c501000f3516de6"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#af0e9087ef54deb687c501000f3516de6">stevensStringLib::unorderedMapifyString</a> (const std::string_view &amp;str, const std::string_view &amp;keyValueSeparator=&quot;:&quot;, const std::string_view &amp;pairSeparator=&quot;,&quot;)</td></tr>
<tr class="separator:af0e9087ef54deb687c501000f3516de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d11bd6e262a33a72a8bf8ea3e2d2829" id="r_a6d11bd6e262a33a72a8bf8ea3e2d2829"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d11bd6e262a33a72a8bf8ea3e2d2829"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a6d11bd6e262a33a72a8bf8ea3e2d2829">stevensStringLib::stringifyMap</a> (const T &amp;map, const std::string_view &amp;keyValueSeparator=&quot;:&quot;, const std::string_view &amp;pairSeparator=&quot;,&quot;)</td></tr>
<tr class="separator:a6d11bd6e262a33a72a8bf8ea3e2d2829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f3a5f620ba28f0fb0061b2cf54cde7" id="r_aa0f3a5f620ba28f0fb0061b2cf54cde7"><td class="memItemLeft" align="right" valign="top">unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aa0f3a5f620ba28f0fb0061b2cf54cde7">stevensStringLib::countLines</a> (const std::string_view &amp;str)</td></tr>
<tr class="separator:aa0f3a5f620ba28f0fb0061b2cf54cde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af737e054dda2d8cc062e45c288304b6e" id="r_af737e054dda2d8cc062e45c288304b6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#af737e054dda2d8cc062e45c288304b6e">stevensStringLib::countFileLines</a> (const std::string &amp;filePath)</td></tr>
<tr class="separator:af737e054dda2d8cc062e45c288304b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c805758cc20928ee0473b0e0f05b85" id="r_a13c805758cc20928ee0473b0e0f05b85"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a13c805758cc20928ee0473b0e0f05b85">stevensStringLib::wrapToWidth</a> (const std::string &amp;str, size_t wrapWidth)</td></tr>
<tr class="separator:a13c805758cc20928ee0473b0e0f05b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1438c0d1b2a167041cbb2f3f95e5220d" id="r_a1438c0d1b2a167041cbb2f3f95e5220d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a1438c0d1b2a167041cbb2f3f95e5220d">stevensStringLib::circularIndex</a> (const std::string_view &amp;str, size_t i)</td></tr>
<tr class="separator:a1438c0d1b2a167041cbb2f3f95e5220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc5f9915fcdea95ccd3536d77964b" id="r_a5bbbc5f9915fcdea95ccd3536d77964b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a5bbbc5f9915fcdea95ccd3536d77964b">stevensStringLib::getWhitespaceString</a> (const std::locale &amp;loc)</td></tr>
<tr class="separator:a5bbbc5f9915fcdea95ccd3536d77964b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6e850aed7869e0cf82a93c42820c1" id="r_a3fe6e850aed7869e0cf82a93c42820c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a3fe6e850aed7869e0cf82a93c42820c1">stevensStringLib::trimWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a3fe6e850aed7869e0cf82a93c42820c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af188690b2237371c369d748223b193" id="r_a6af188690b2237371c369d748223b193"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a6af188690b2237371c369d748223b193">stevensStringLib::charToString</a> (const char &amp;c)</td></tr>
<tr class="separator:a6af188690b2237371c369d748223b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac70294354fd548c0fcc74c31f3b924" id="r_aaac70294354fd548c0fcc74c31f3b924"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aaac70294354fd548c0fcc74c31f3b924">stevensStringLib::eraseNonNumericChars</a> (std::string str)</td></tr>
<tr class="separator:aaac70294354fd548c0fcc74c31f3b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69119030f08c04d17f5ec4c59c0a8b6" id="r_ac69119030f08c04d17f5ec4c59c0a8b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac69119030f08c04d17f5ec4c59c0a8b6">stevensStringLib::reverse</a> (std::string str)</td></tr>
<tr class="separator:ac69119030f08c04d17f5ec4c59c0a8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc7a7ba1770dbc595aa351f8137bb4e" id="r_a3dc7a7ba1770dbc595aa351f8137bb4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a3dc7a7ba1770dbc595aa351f8137bb4e">stevensStringLib::isPalindrome</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a3dc7a7ba1770dbc595aa351f8137bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09205aa6fe016654d45436a4048a027" id="r_af09205aa6fe016654d45436a4048a027"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#af09205aa6fe016654d45436a4048a027">stevensStringLib::multiply</a> (const std::string_view str, const int x)</td></tr>
<tr class="memdesc:af09205aa6fe016654d45436a4048a027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string str, concatenate it onto an empty string a given amount of times x, creating a multiply-like effect.  <br /></td></tr>
<tr class="separator:af09205aa6fe016654d45436a4048a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058ec839e8d8052fa05c951a4fc0f15" id="r_a7058ec839e8d8052fa05c951a4fc0f15"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a7058ec839e8d8052fa05c951a4fc0f15">stevensStringLib::format</a> (std::string str, const std::vector&lt; std::string &gt; &amp;replaceStrs, const char &amp;openingFormatBrace='{', const char &amp;closingFormatBrace='}')</td></tr>
<tr class="memdesc:a7058ec839e8d8052fa05c951a4fc0f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string by replacing format braces with strings stored within a vector.  <br /></td></tr>
<tr class="separator:a7058ec839e8d8052fa05c951a4fc0f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e3a24c71708945cfc73bf2625604c0" id="r_ac5e3a24c71708945cfc73bf2625604c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac5e3a24c71708945cfc73bf2625604c0">stevensStringLib::format</a> (std::string str, const std::unordered_map&lt; std::string, std::string &gt; &amp;formatStrMap, const char &amp;openingFormatBrace='{', const char &amp;closingFormatBrace='}')</td></tr>
<tr class="memdesc:ac5e3a24c71708945cfc73bf2625604c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string by replacing format braces with strings stored within a map. Variant of the vector-based format, where the values of the substrings within format braces are keys of a map parameter, and their replacements are the respective values of those keys.  <br /></td></tr>
<tr class="separator:ac5e3a24c71708945cfc73bf2625604c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac671732a9d22e768387c95c5f9d524a7" id="r_ac671732a9d22e768387c95c5f9d524a7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#ac671732a9d22e768387c95c5f9d524a7">stevensStringLib::replaceSubstr</a> (std::string str, const std::string &amp;targetSubstr, const std::string &amp;replaceSubstr, size_t quantity=std::string::npos, const std::string &amp;startFrom=&quot;left&quot;)</td></tr>
<tr class="memdesc:ac671732a9d22e768387c95c5f9d524a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces instances of a target substring in a given string with another substring of your choice.  <br /></td></tr>
<tr class="separator:ac671732a9d22e768387c95c5f9d524a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1be0b03e259aaa8af0f604f104c364" id="r_a4c1be0b03e259aaa8af0f604f104c364"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#a4c1be0b03e259aaa8af0f604f104c364">stevensStringLib::eraseTrailingZeroes</a> (const float &amp;num)</td></tr>
<tr class="memdesc:a4c1be0b03e259aaa8af0f604f104c364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a floating point number num, remove trailing zeroes up to a certain point of given precision. Return the resulting number as a string.  <br /></td></tr>
<tr class="separator:a4c1be0b03e259aaa8af0f604f104c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43e43c8ee6cd84e832998e00c8564fc" id="r_af43e43c8ee6cd84e832998e00c8564fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#af43e43c8ee6cd84e832998e00c8564fc">stevensStringLib::csvAppend</a> (std::string &amp;csvs, const std::string &amp;valueToAdd, const char delimiter=',')</td></tr>
<tr class="memdesc:af43e43c8ee6cd84e832998e00c8564fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of delimited values (assumed to be comma-separated values, csvs), append a given value to the string of csvs.  <br /></td></tr>
<tr class="separator:af43e43c8ee6cd84e832998e00c8564fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbe94d5777094f6671fd77997f5d4b5" id="r_aafbe94d5777094f6671fd77997f5d4b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stevensStringLib_8h.html#aafbe94d5777094f6671fd77997f5d4b5">stevensStringLib::scramble</a> (std::string str)</td></tr>
<tr class="memdesc:aafbe94d5777094f6671fd77997f5d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string, randomly scramble the position of all of its characters.  <br /></td></tr>
<tr class="separator:aafbe94d5777094f6671fd77997f5d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An easy-to-use C++ library with convenient functions for working with strings. </p>
<dl class="section author"><dt>Author</dt><dd>Jeff Stevens (<a href="#" onclick="location.href='mai'+'lto:'+'jef'+'f@'+'buc'+'ep'+'hal'+'us'+'stu'+'di'+'os.'+'co'+'m'; return false;">jeff@<span class="obfuscator">.nosp@m.</span>buce<span class="obfuscator">.nosp@m.</span>phalu<span class="obfuscator">.nosp@m.</span>sstu<span class="obfuscator">.nosp@m.</span>dios.<span class="obfuscator">.nosp@m.</span>com</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1-12-24 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) Bucephalus Studios 2023</dd></dl>
<p>Created and released under the MIT license. See the LICENSE file in the repository folder.</p>
<p>If you'd like to buy me a coffee or send me a tip for my work on this library, you can do that here: <a href="https://ko-fi.com/bucephalus_studios">https://ko-fi.com/bucephalus_studios</a></p>
<p>Thank you very, very much for being interested in my code! I hope it serves you well &lt;3 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac92dec2b0a512e7141df8aa6dd63c86f" name="ac92dec2b0a512e7141df8aa6dd63c86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92dec2b0a512e7141df8aa6dd63c86f">&#9670;&#160;</a></span>boolToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::boolToString </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a boolean value to a string value.</p>
<p>Credit to OJ and Igor Ganapolsky: <a href="https://stackoverflow.com/a/29798/16511184">https://stackoverflow.com/a/29798/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>- The boolean value we wish to convert to a string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- The boolean value represented as a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c1a2d1fc6655066097dcdca512de63f" name="a5c1a2d1fc6655066097dcdca512de63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1a2d1fc6655066097dcdca512de63f">&#9670;&#160;</a></span>cap1stChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::cap1stChar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string with the first letter capitalized. If the string is empty, then we just return the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we want to capitalize the first letter of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The string str with the first letter capitalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6af188690b2237371c369d748223b193" name="a6af188690b2237371c369d748223b193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af188690b2237371c369d748223b193">&#9670;&#160;</a></span>charToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::charToString </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a character c, convert it to a std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- The character we'd like to convert to a string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A string representing the character c. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1438c0d1b2a167041cbb2f3f95e5220d" name="a1438c0d1b2a167041cbb2f3f95e5220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1438c0d1b2a167041cbb2f3f95e5220d">&#9670;&#160;</a></span>circularIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char stevensStringLib::circularIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string and an integer representing an index, return a single character from the string by the process of circular indexing.</p>
<p>Circular indexing is performed by indexing over the string from left to right. Once the index exceeds the length of the string, we begin indexing again from the lefthand side of the string and repeat the process until we stop at the final index. We return the character at that final index.</p>
<p>Example: circularIndex("Hello world!", 13) returns 'e', as we loop around to 'H' at 12 and index one space further to reach 'e'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are circularly indexing through. </td></tr>
    <tr><td class="paramname">i</td><td>- The index of the string to circularly index to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">char</td><td>- A character found in str that has been circularly indexed to at position i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaee6af848c3910d695c0c191dd182c7d" name="aaee6af848c3910d695c0c191dd182c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee6af848c3910d695c0c191dd182c7d">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>In C++23 and onward, please use the std::string::contains() method instead of this function.</dd></dl>
<p>Given a string, determine whether it has an occurrence of a character somewhere within it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are examining to see if it contains the substring. </td></tr>
    <tr><td class="paramname">ch</td><td>- The char we are checking to see if it is contained in str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- indicates that input string contains the substring (true) or not (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af83dd4ced359aa4728438f8e469e6f2e" name="af83dd4ced359aa4728438f8e469e6f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83dd4ced359aa4728438f8e469e6f2e">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>In C++23 and onward, please use the std::string::contains() method instead of this function.</dd></dl>
<p>Given a string, determine whether it has an occurrence of the substring somewhere within it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are examining to see if it contains the substring. </td></tr>
    <tr><td class="paramname">substring</td><td>- The substring we are checking to if it is contained in str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- indicates that input string contains the substring (true) or not (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ffddbdb3678e6b288f2950cc9bce27" name="a32ffddbdb3678e6b288f2950cc9bce27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ffddbdb3678e6b288f2950cc9bce27">&#9670;&#160;</a></span>containsOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::containsOnly </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string, determine if it contains only the characters in the given string. </p>
<p>Example: containsOnly("11101112222","12")</p>
<p>Result: false, str contains the character '0', which is not equal to '1', or '2';</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking to see if it only contains characters present in the chars string. </td></tr>
    <tr><td class="paramname">chars</td><td>- A string of characters we are checking to see if str contains any characters that are not in chars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if str contains only instances of keys in substrs. False if str contains at least one substring that is not present as a key in substrs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af737e054dda2d8cc062e45c288304b6e" name="af737e054dda2d8cc062e45c288304b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af737e054dda2d8cc062e45c288304b6e">&#9670;&#160;</a></span>countFileLines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stevensStringLib::countFileLines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the path to a file, count how many lines are in the file and return the integer count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>- The path to the file we want to count the number of lines of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>- The integer number of lines that the file contains. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0f3a5f620ba28f0fb0061b2cf54cde7" name="aa0f3a5f620ba28f0fb0061b2cf54cde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f3a5f620ba28f0fb0061b2cf54cde7">&#9670;&#160;</a></span>countLines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long int stevensStringLib::countLines </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string, count how many lines are in that string and return the integer count.</p>
<p>Solution from: <a href="https://stackoverflow.com/questions/3482064/counting-the-number-of-lines-in-a-text-file">https://stackoverflow.com/questions/3482064/counting-the-number-of-lines-in-a-text-file</a></p>
<p>TODO: Concerned with line counting problems presented here: <a href="https://stackoverflow.com/a/843484/16511184">https://stackoverflow.com/a/843484/16511184</a> This function counts only newline characters, not all of the ways new lines can indicated via characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string which we wish to count the number of lines of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>- The integer count of the number of lines that the string str has. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af43e43c8ee6cd84e832998e00c8564fc" name="af43e43c8ee6cd84e832998e00c8564fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43e43c8ee6cd84e832998e00c8564fc">&#9670;&#160;</a></span>csvAppend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stevensStringLib::csvAppend </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>csvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>valueToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of delimited values (assumed to be comma-separated values, csvs), append a given value to the string of csvs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csvs</td><td>A string of values delimited by the parameter delimiter which we will add a value onto the end of </td></tr>
    <tr><td class="paramname">valueToAdd</td><td>A string value to append to the end of csvs </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character delimiting the csvs string. ',' by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None,but</td><td>operates by reference to add value to the end of parameter csvs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb69a84e86b3cd194600e38aff7c2f19" name="acb69a84e86b3cd194600e38aff7c2f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb69a84e86b3cd194600e38aff7c2f19">&#9670;&#160;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::endsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a string to see if it ends with a substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking the end of to see if it ends with substr. </td></tr>
    <tr><td class="paramname">substr</td><td>- The substr we are checking to see if str ends with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if the string str ends with substr. False if the str does not end with with substr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3dfd6d4329ab7bf69fb1cfd475508c7" name="ad3dfd6d4329ab7bf69fb1cfd475508c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dfd6d4329ab7bf69fb1cfd475508c7">&#9670;&#160;</a></span>eraseCharsFromEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseCharsFromEnd </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string str, erase the last n characters of the string.</p>
<p>Credit to Varun: <a href="https://thispointer.com/remove-last-n-characters-from-a-string-in-c/">https://thispointer.com/remove-last-n-characters-from-a-string-in-c/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we want to erase characters from the end of. </td></tr>
    <tr><td class="paramname">n</td><td>- The number of characters we want to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The string str having n characters erased from the end of it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b92ac54e4eb76eb32d7fd7ccd0f8de3" name="a9b92ac54e4eb76eb32d7fd7ccd0f8de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b92ac54e4eb76eb32d7fd7ccd0f8de3">&#9670;&#160;</a></span>eraseCharsFromStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseCharsFromStart </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string str, erase the first n characters of the string. </p>
<p>Credit to Michael Krelin: <a href="https://stackoverflow.com/a/12692267/16511184">https://stackoverflow.com/a/12692267/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we want to erase characters from the start of. </td></tr>
    <tr><td class="paramname">n</td><td>- The number of characters we want to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaac70294354fd548c0fcc74c31f3b924" name="aaac70294354fd548c0fcc74c31f3b924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac70294354fd548c0fcc74c31f3b924">&#9670;&#160;</a></span>eraseNonNumericChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseNonNumericChars </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all non-numeric characters from a string and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string to release all non-numeric chars from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The string parameter we passed in, but all of its non-numeric characters removed from it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c1be0b03e259aaa8af0f604f104c364" name="a4c1be0b03e259aaa8af0f604f104c364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1be0b03e259aaa8af0f604f104c364">&#9670;&#160;</a></span>eraseTrailingZeroes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseTrailingZeroes </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a floating point number num, remove trailing zeroes up to a certain point of given precision. Return the resulting number as a string. </p>
<p>@credit <a href="https://stackoverflow.com/a/57883193/16511184">https://stackoverflow.com/a/57883193/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The number we are removing trailing zeroes from. //</td></tr>
    <tr><td class="paramname">precision</td><td>The precision of the floating point number we eliminate trailing zeroes up to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string version of the parameter num with all of its trailing zeroes removed up until the given point of precision. </dd></dl>

</div>
</div>
<a id="aba5eea65943a19263c1a018dda78fe81" name="aba5eea65943a19263c1a018dda78fe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5eea65943a19263c1a018dda78fe81">&#9670;&#160;</a></span>findAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; stevensStringLib::findAll </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string str, find all occurrences of a character within it. Returns a vector of all of the indices that the character occurs at within the string str.</p>
<p>Credit to Benjamin Lindley: <a href="https://stackoverflow.com/a/4034809">https://stackoverflow.com/a/4034809</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are searching for the substring in. </td></tr>
    <tr><td class="paramname">ch</td><td>- The character we are looking for within string str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::vector&lt;size_t&gt;</td><td>- A vector containing all indices in increasing order that ch occurs at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bcbc19ce3501fa3e06635657c2ded45" name="a4bcbc19ce3501fa3e06635657c2ded45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcbc19ce3501fa3e06635657c2ded45">&#9670;&#160;</a></span>findAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; stevensStringLib::findAll </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string str, find all occurrences of a substring within it. Returns a vector of all of the indices that the substring occurs at within the string str.</p>
<p>Credit to Benjamin Lindley: <a href="https://stackoverflow.com/a/4034809">https://stackoverflow.com/a/4034809</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are searching for the substring in. </td></tr>
    <tr><td class="paramname">substr</td><td>- The substring we are looking for within string str.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::vector&lt;size_t&gt;</td><td>- A vector containing all indices in increasing order that the substr occurs at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5e3a24c71708945cfc73bf2625604c0" name="ac5e3a24c71708945cfc73bf2625604c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e3a24c71708945cfc73bf2625604c0">&#9670;&#160;</a></span>format() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::format </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>formatStrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>openingFormatBrace</em> = <code>'{'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>closingFormatBrace</em> = <code>'}'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a string by replacing format braces with strings stored within a map. Variant of the vector-based format, where the values of the substrings within format braces are keys of a map parameter, and their replacements are the respective values of those keys. </p>
<p>Example: std::string formattedString = <a class="el" href="stevensStringLib_8h.html#a7058ec839e8d8052fa05c951a4fc0f15" title="Formats a string by replacing format braces with strings stored within a vector.">stevensStringLib::format</a>( "{greeting}, {addressee}. {question}?", { {"greeting", "howdy" } {"addressee", "pardner" } {"question", "how are you today" } } ); //formattedString == "howdy, pardner. how are you today?"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string we are replacing the format brace enclosed substrings of. </td></tr>
    <tr><td class="paramname">formatStrMap</td><td>A map of strings containing keys, which correspond to the the brace-enclosed substrings, and values which will replace their matching brace-enclosed substrings. </td></tr>
    <tr><td class="paramname">openingFormatBrace</td><td>The character marking the beginning of a brace-enclosed substring. </td></tr>
    <tr><td class="paramname">closingFormatBrace</td><td>The character marking the end of a brace-enclosed substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">str</td><td>modified with the replacements made of its format braces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7058ec839e8d8052fa05c951a4fc0f15" name="a7058ec839e8d8052fa05c951a4fc0f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7058ec839e8d8052fa05c951a4fc0f15">&#9670;&#160;</a></span>format() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::format </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>replaceStrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>openingFormatBrace</em> = <code>'{'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>closingFormatBrace</em> = <code>'}'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formats a string by replacing format braces with strings stored within a vector. </p>
<dl class="section author"><dt>Authors</dt><dd>VikingOfValhalla, Jeff Stevens</dd></dl>
<p>Example: std::string testing = <a class="el" href="stevensStringLib_8h.html#a7058ec839e8d8052fa05c951a4fc0f15" title="Formats a string by replacing format braces with strings stored within a vector.">stevensStringLib::format</a>({"testing {0}{1}", "1", "This is another test"}); //testing == "testing 1 This is another test"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string that we'd like to replace the contents of formatted braces with. </td></tr>
    <tr><td class="paramname">replaceStrs</td><td>- A vector containing all of the strings that we'd like to replace str's format braces with in order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Str</td><td>modified with the replacements made of its format braces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bbbc5f9915fcdea95ccd3536d77964b" name="a5bbbc5f9915fcdea95ccd3536d77964b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbc5f9915fcdea95ccd3536d77964b">&#9670;&#160;</a></span>getWhitespaceString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::getWhitespaceString </td>
          <td>(</td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a locale, return all of the whitespace characters for that locale in a string.</p>
<p>Credit to Nathan Oliver: <a href="https://stackoverflow.com/a/36311304/16511184">https://stackoverflow.com/a/36311304/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>- The locale which we want to obtain a string of all whitespace characters for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A string of all whitespace characters defined in the given locale. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ee6720d9d0028eb7891e9360b6c68a" name="a31ee6720d9d0028eb7891e9360b6c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ee6720d9d0028eb7891e9360b6c68a">&#9670;&#160;</a></span>isFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detects if a string is in the form of a valid c++ floating point type (float, double, long double).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we are checking to see if it represents a floating point type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if the string str represents a floating point type. False otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eccf0d2f3d7970fc342f4c2faac274a" name="a8eccf0d2f3d7970fc342f4c2faac274a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eccf0d2f3d7970fc342f4c2faac274a">&#9670;&#160;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isInteger </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detects if a string is in the form of a valid C++ integer/integral type (bool, char, short, int, long int, long long int).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we are checking to see if it represents an integer/integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if the string str represents an integer, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac011598c8d05818536e48fd96ca2b12d" name="ac011598c8d05818536e48fd96ca2b12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac011598c8d05818536e48fd96ca2b12d">&#9670;&#160;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detects if a string consists of only numeric characters, and potentially a decimal point and leading negative sign.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking to see if it represents a number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if the string represents a number. False if otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dc7a7ba1770dbc595aa351f8137bb4e" name="a3dc7a7ba1770dbc595aa351f8137bb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc7a7ba1770dbc595aa351f8137bb4e">&#9670;&#160;</a></span>isPalindrome()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isPalindrome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks to see if a std::string is a palindrime or not (the reversed order of characters equals the original order of characters). Note well that character case, spacing, and punctuation present in classic English palindromes like "A man, a plan, a canal, panama" prevent them from being valid C++ palindromes with this function, as the reverse order of this exact string is "amanap ,lanac a ,nalp a ,nam A" is not equivalent to the original order of characters.</p>
<p>Credit to Cubbi: <a href="https://stackoverflow.com/a/8362657/16511184">https://stackoverflow.com/a/8362657/16511184</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- true if str is a palindrome, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff84548f35ed049a4cba5ac01fdf4a6" name="a5ff84548f35ed049a4cba5ac01fdf4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff84548f35ed049a4cba5ac01fdf4a6">&#9670;&#160;</a></span>isScientificNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isScientificNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string, check to see if it represents a number in scientific notation. </p>
<p>Useful to check numbers that may cause overflow or underflow before they are checked by checked with isInteger or may be too precise to be checked with isFloat. Essentially, this function checks to see if you have a floating point type number on the left side of a string divided by an x,X,*,e, or an E, and either a 10^n or n on the right side.</p>
<p>Example: isScientificNumber(3.521x10^3) == true isScientificNumber(4.68E4) == true isScientificNumber(9001) == false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking to see if it represents a number in standard notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if the string represents a number in scientific notation. False if the string does NOT represent a number in scientific notation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf228e15ecf74d3127799a6d28b014a8" name="abf228e15ecf74d3127799a6d28b014a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf228e15ecf74d3127799a6d28b014a8">&#9670;&#160;</a></span>isStandardNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isStandardNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string, check to see if it represents a number in standard notation. </p>
<p>Useful to check numbers that may cause overflow or underflow when checked with isInteger or may be too precise to be checked with isFloat.</p>
<p>Example: isStandardNumber("-214748364721474836472147483647.123123123123123") == true isStandardNumber("2.5e2") == false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking to see if it represents a number in standard notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if str represents a number in standard notation. False if str does not represent a number in standard notation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a06dfefa8e30a9e16391ac301f0954a" name="a0a06dfefa8e30a9e16391ac301f0954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a06dfefa8e30a9e16391ac301f0954a">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omitEmptyStrings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a vector of strings, concatenate them all into a single string, separating each string element in the final returned string by a given separator string. </p>
<p>Essentially, reverses the operation of the separate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of stringlike objects we wish to concatenate together </td></tr>
    <tr><td class="paramname">separator</td><td>A string of characters that will be placed between all concatenated elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of all of the string elements in the vector concatenated with the separator string between each element. </dd></dl>

</div>
</div>
<a id="a93a3b051465b829d63a0c0867193f4cb" name="a93a3b051465b829d63a0c0867193f4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a3b051465b829d63a0c0867193f4cb">&#9670;&#160;</a></span>mapifyString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; stevensStringLib::mapifyString </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: Problem!!! Data could potentially contain separator strings. We need to prevent this, possibly by requiring JSON formatting?</p>
<p>Given an input string str that can represent a map&lt;std::string,std::string, take two separator strings and separate the pairs from eachother, and the keys and values from each other. Then insert each key value pair into a std::map&lt;std::string,std::string&gt; object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to convert into a map&lt;std::string,std::string&gt;. </td></tr>
    <tr><td class="paramname">keyValueSeparator</td><td>- The string in str using to separate keys from values. </td></tr>
    <tr><td class="paramname">pairSeparator</td><td>- The string in str we are using separate pairs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::map</td><td>- A map object of string-string key-value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a412f31d61fe4c1f5158e878100267638" name="a412f31d61fe4c1f5158e878100267638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412f31d61fe4c1f5158e878100267638">&#9670;&#160;</a></span>mapifyStringHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stevensStringLib::mapifyStringHelper </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>pairSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the work step for mapifyString and unordered_mapifyString. </p>
<p>This function does not need to be directly called, instead, please use mapifyString() and unorderedMapifyString() </p>

</div>
</div>
<a id="af09205aa6fe016654d45436a4048a027" name="af09205aa6fe016654d45436a4048a027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09205aa6fe016654d45436a4048a027">&#9670;&#160;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::multiply </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string str, concatenate it onto an empty string a given amount of times x, creating a multiply-like effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are multiplying. </td></tr>
    <tr><td class="paramname">x</td><td>- The number of times to concatenate str onto the empty string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>empty string "" with str concatenated onto its righthand side x times. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc289dc431709640aac960c1322f4278" name="acc289dc431709640aac960c1322f4278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc289dc431709640aac960c1322f4278">&#9670;&#160;</a></span>removeWhitespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::removeWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all tabs, spaces, newlines, and anything else from a string that is defined as whitespace in the current locale.</p>
<p>Learn what is defined as whitespace: <a href="https://en.cppreference.com/w/cpp/string/byte/isspace">https://en.cppreference.com/w/cpp/string/byte/isspace</a> Credit to Michael Steller: <a href="https://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c">https://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string from which we wish to remove all the whitespace from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The input string but with all of the whitespace removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac671732a9d22e768387c95c5f9d524a7" name="ac671732a9d22e768387c95c5f9d524a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac671732a9d22e768387c95c5f9d524a7">&#9670;&#160;</a></span>replaceSubstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::replaceSubstr </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>targetSubstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceSubstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>quantity</em> = <code>std::string::npos</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>startFrom</em> = <code>&quot;left&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces instances of a target substring in a given string with another substring of your choice. </p>
<p>Example: resultString = <a class="el" href="stevensStringLib_8h.html#ac671732a9d22e768387c95c5f9d524a7" title="Replaces instances of a target substring in a given string with another substring of your choice.">stevensStringLib::replaceSubstr</a>( "Gee, this neighborhood sure seems safe!", " ", "BANG!" ); //resultString == "Gee,BANG!thisBANG!neighborhoodBANG!sureBANG!seemsBANG!safe!"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string we are replacing instances of the target substring within. </td></tr>
    <tr><td class="paramname">targetSubstr</td><td>The substring we are replacing with replaceSubstr in str. </td></tr>
    <tr><td class="paramname">replaceSubstr</td><td>The substring we are using to replace instances of targetSubstr. </td></tr>
    <tr><td class="paramname">quantity</td><td>The number of times we wish to make replacements. By default, it replaces all occurrences of the target substring. </td></tr>
    <tr><td class="paramname">startFrom</td><td>The side of the string we would like to begin making replacements from. By default, we begin from the left. Valid values are "left" and "right". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac69119030f08c04d17f5ec4c59c0a8b6" name="ac69119030f08c04d17f5ec4c59c0a8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69119030f08c04d17f5ec4c59c0a8b6">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::reverse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reverses the order of a string's characters using std::reverse().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The reversed string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafbe94d5777094f6671fd77997f5d4b5" name="aafbe94d5777094f6671fd77997f5d4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbe94d5777094f6671fd77997f5d4b5">&#9670;&#160;</a></span>scramble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::scramble </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string, randomly scramble the position of all of its characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to scramble</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string with all of the same characters as str, but scrambled into a random order </dd></dl>

</div>
</div>
<a id="a1b29b2661c1430ffbac04f0e8a0876a3" name="a1b29b2661c1430ffbac04f0e8a0876a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b29b2661c1430ffbac04f0e8a0876a3">&#9670;&#160;</a></span>separate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; stevensStringLib::separate </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>separator</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omitEmptyStrings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Separates a string by a separator character. Returns a vector of strings that were separated.</p>
<p>Example:</p>
<p>std::vector&lt;std::string&gt; result = separate("John,Gina,Sebastian,Nick");</p>
<p>//Value of result is: {"John","Gina","Sebastian","Nick"}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we intend to separate with this function. </td></tr>
    <tr><td class="paramname">separator</td><td>- The char we intend to separate str by. </td></tr>
    <tr><td class="paramname">omitEmptyStrings</td><td>- If true, do not include empty strings in the returned vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::vector&lt;std::string&gt;</td><td>- A vector of substrings of the original string that have been split up by all occurrences of the separator parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff7fd2ec486153c3481c1137155c0980" name="aff7fd2ec486153c3481c1137155c0980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7fd2ec486153c3481c1137155c0980">&#9670;&#160;</a></span>separate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; stevensStringLib::separate </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omitEmptyStrings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of separate that lets you separate by strings instead of chars.</p>
<p>Separates a string by a separator substring. Returns a vector of strings that were separated by the separator substring.</p>
<p>Example:</p>
<p>std::vector&lt;std::string&gt; result = separate("Wakko and Yakko and Dot", " and ");</p>
<p>//Value of result is: {"Wakko","Yakko","Dot"}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we intend to separate with this function. </td></tr>
    <tr><td class="paramname">separator</td><td>- The substring of str we intend to separate it by. </td></tr>
    <tr><td class="paramname">omitEmptyStrings</td><td>- If true, do not include empty strings in the returned vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::vector&lt;std::string&gt;</td><td>- A vector of substrings of the original string that have been split up by all occurrences of the separator parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a608c79000fd38c904b100d5cf9120299" name="a608c79000fd38c904b100d5cf9120299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608c79000fd38c904b100d5cf9120299">&#9670;&#160;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a string to see if it begins with a substring. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>In C++20 and onward, please use std::string.starts_with instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we are checking to see if it begins with another substring. </td></tr>
    <tr><td class="paramname">substr</td><td>- The substring we are checking the beginning of str against to see if they are equal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if the string str begins with substr. False if the string str does NOT begin with substr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d11bd6e262a33a72a8bf8ea3e2d2829" name="a6d11bd6e262a33a72a8bf8ea3e2d2829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d11bd6e262a33a72a8bf8ea3e2d2829">&#9670;&#160;</a></span>stringifyMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::stringifyMap </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an map or unordered_map of strings, turn it into a string of keys and values paired together, separated by delimiting characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>- Th map or unordered_map with string keys and values which we intend to turn into a string. </td></tr>
    <tr><td class="paramname">keyValueSeparator</td><td>- The string that separates keys from their values in the returned string. </td></tr>
    <tr><td class="paramname">pairSeparator</td><td>- The string that separates key-value pairs in the returned string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- The all contents of the unordered map turned into a string list of separated key-value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66cee1aced824a0f8ee615dbf7035478" name="a66cee1aced824a0f8ee615dbf7035478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cee1aced824a0f8ee615dbf7035478">&#9670;&#160;</a></span>stringToBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::stringToBool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes in a string and checks to see if it is a representation of the word "true" or a string representing a non-zero number. In those cases, return a true bool. In all other cases, return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we are converting to a bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>- True if str is a form of the word true or 0, and false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd42f6dfa6de31b27f58781c57a7762e" name="acd42f6dfa6de31b27f58781c57a7762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd42f6dfa6de31b27f58781c57a7762e">&#9670;&#160;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::toLower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string with all characters in lowercase if possible. </p>

</div>
</div>
<a id="a9c0bf954dd6582f3d6d8781f079689f2" name="a9c0bf954dd6582f3d6d8781f079689f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0bf954dd6582f3d6d8781f079689f2">&#9670;&#160;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::toUpper </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string with all characters in uppercase if possible.</p>
<p>Credit to this article: <a href="https://www.geeksforgeeks.org/conversion-whole-string-uppercase-lowercase-using-stl-c/">https://www.geeksforgeeks.org/conversion-whole-string-uppercase-lowercase-using-stl-c/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we would like to make all uppercase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">string</td><td>- The parameter str, but all in uppercase!</td></tr>
  </table>
  </dd>
</dl>
<p>` </p>

</div>
</div>
<a id="a5d846cb4529597c7fd190c026892ff6d" name="a5d846cb4529597c7fd190c026892ff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d846cb4529597c7fd190c026892ff6d">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>charsToTrim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string and integer X, erase (trim) X characters from both the beginning and end of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- A string we would like to trim the characters from. </td></tr>
    <tr><td class="paramname">charsToTrim</td><td>- The number of characters to trim from the beginning and end of the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A modified version of the string str, with a number characters from both the beginning and end of the string trimmed off equal to charsToTrim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe6e850aed7869e0cf82a93c42820c1" name="a3fe6e850aed7869e0cf82a93c42820c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe6e850aed7869e0cf82a93c42820c1">&#9670;&#160;</a></span>trimWhitespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::trimWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all leading and trailing whitespace from a string (spaces, tabs, newlines, etc.), then return it.</p>
<p>Credit to GManNickG and Kef Schecter: <a href="https://stackoverflow.com/a/1798170">https://stackoverflow.com/a/1798170</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string to remove all of the leading and trailing whitespaces from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- str modified by removing all of its leading and trailing whitespaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0e9087ef54deb687c501000f3516de6" name="af0e9087ef54deb687c501000f3516de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e9087ef54deb687c501000f3516de6">&#9670;&#160;</a></span>unorderedMapifyString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::string &gt; stevensStringLib::unorderedMapifyString </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of mapifyString that works for std::unordered_maps </p>

</div>
</div>
<a id="a13c805758cc20928ee0473b0e0f05b85" name="a13c805758cc20928ee0473b0e0f05b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c805758cc20928ee0473b0e0f05b85">&#9670;&#160;</a></span>wrapToWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::wrapToWidth </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wrapWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string and integer describing the total number of characters that can exist in a line of text, wrap the text by adding newlines between words so it may fit within a certain width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string which we wish to wrap to a certain width. </td></tr>
    <tr><td class="paramname">wrapWidth</td><td>- The width in number of characters we wish to wrap to each line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">std::string</td><td>- A modified version of the parameter str, with newlines added to it so that it fits within a certain character width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
