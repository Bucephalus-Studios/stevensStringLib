<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stevensStringLib: stevensStringLib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">stevensStringLib<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">stevensStringLib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86fbb60ec5f626744264a2e0ab5066a9" id="r_a86fbb60ec5f626744264a2e0ab5066a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a86fbb60ec5f626744264a2e0ab5066a9">contains</a> (const std::string &amp;str, const std::string &amp;substring)</td></tr>
<tr class="separator:a86fbb60ec5f626744264a2e0ab5066a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75dd17730068a151f3f34d299cfb7fa" id="r_ae75dd17730068a151f3f34d299cfb7fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#ae75dd17730068a151f3f34d299cfb7fa">separate</a> (const std::string &amp;str, const std::string &amp;separator=&quot;,&quot;, const bool &amp;omitEmptyStrings=true)</td></tr>
<tr class="separator:ae75dd17730068a151f3f34d299cfb7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105280ad458e2aeea94c59174c53ad82" id="r_a105280ad458e2aeea94c59174c53ad82"><td class="memItemLeft" align="right" valign="top"><a id="a105280ad458e2aeea94c59174c53ad82" name="a105280ad458e2aeea94c59174c53ad82"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sep</b> (const std::string &amp;str, const std::string &amp;separator=&quot;,&quot;, const bool &amp;omitEmptyStrings=true)</td></tr>
<tr class="memdesc:a105280ad458e2aeea94c59174c53ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="namespacestevensStringLib.html#ae75dd17730068a151f3f34d299cfb7fa">separate()</a> <br /></td></tr>
<tr class="separator:a105280ad458e2aeea94c59174c53ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616701916cbe9be295361a93b7755f06" id="r_a616701916cbe9be295361a93b7755f06"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a616701916cbe9be295361a93b7755f06">cap1stChar</a> (std::string input)</td></tr>
<tr class="separator:a616701916cbe9be295361a93b7755f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1197f49a832b1beab045ad096c2758" id="r_a7c1197f49a832b1beab045ad096c2758"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a7c1197f49a832b1beab045ad096c2758">toUpper</a> (std::string &amp;str)</td></tr>
<tr class="separator:a7c1197f49a832b1beab045ad096c2758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734c980bfd536f7929cd051283ea192c" id="r_a734c980bfd536f7929cd051283ea192c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a734c980bfd536f7929cd051283ea192c">isInteger</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a734c980bfd536f7929cd051283ea192c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ee6720d9d0028eb7891e9360b6c68a" id="r_a31ee6720d9d0028eb7891e9360b6c68a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a31ee6720d9d0028eb7891e9360b6c68a">isFloat</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a31ee6720d9d0028eb7891e9360b6c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72692e6b9776275f737e5087ee1b87cb" id="r_a72692e6b9776275f737e5087ee1b87cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a72692e6b9776275f737e5087ee1b87cb">isNumber</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a72692e6b9776275f737e5087ee1b87cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcc004e8edffbe6db42387a957a3c1b" id="r_a1bcc004e8edffbe6db42387a957a3c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a1bcc004e8edffbe6db42387a957a3c1b">string_to_bool</a> (std::string &amp;input)</td></tr>
<tr class="separator:a1bcc004e8edffbe6db42387a957a3c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34011fafa3843edec6ee27c5ad6dcf95" id="r_a34011fafa3843edec6ee27c5ad6dcf95"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a34011fafa3843edec6ee27c5ad6dcf95">bool_to_string</a> (const bool &amp;input)</td></tr>
<tr class="separator:a34011fafa3843edec6ee27c5ad6dcf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673dffa5269fea2d342f27372c68f9e5" id="r_a673dffa5269fea2d342f27372c68f9e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a673dffa5269fea2d342f27372c68f9e5">trim</a> (const std::string &amp;input, const int &amp;charsToTrim)</td></tr>
<tr class="separator:a673dffa5269fea2d342f27372c68f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc289dc431709640aac960c1322f4278" id="r_acc289dc431709640aac960c1322f4278"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#acc289dc431709640aac960c1322f4278">removeWhitespace</a> (std::string str)</td></tr>
<tr class="separator:acc289dc431709640aac960c1322f4278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3c2bc3c3c819fbc8d8e8de6a3d8423" id="r_a2c3c2bc3c3c819fbc8d8e8de6a3d8423"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a2c3c2bc3c3c819fbc8d8e8de6a3d8423">mapifyString</a> (std::string str, std::string keyValueSeparator, std::string pairSeparator, bool ignoreWhitespace=true)</td></tr>
<tr class="separator:a2c3c2bc3c3c819fbc8d8e8de6a3d8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400139dff51fd0cad31ad2f0fcbc1274" id="r_a400139dff51fd0cad31ad2f0fcbc1274"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a400139dff51fd0cad31ad2f0fcbc1274">unordered_mapifyString</a> (std::string str, std::string keyValueSeparator=&quot;:&quot;, std::string pairSeparator=&quot;,&quot;, bool ignoreWhitespace=true)</td></tr>
<tr class="separator:a400139dff51fd0cad31ad2f0fcbc1274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810d50a0e7386192bd72a28dbdd3985b" id="r_a810d50a0e7386192bd72a28dbdd3985b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a810d50a0e7386192bd72a28dbdd3985b">stringifyUnordered_map</a> (std::unordered_map&lt; std::string, std::string &gt; umap, std::string keyValueSeparator=&quot;:&quot;, std::string pairSeparator=&quot;,&quot;)</td></tr>
<tr class="separator:a810d50a0e7386192bd72a28dbdd3985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5ecb7f12940ba9db9f0633717c6304" id="r_aec5ecb7f12940ba9db9f0633717c6304"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#aec5ecb7f12940ba9db9f0633717c6304">countLines</a> (std::string str)</td></tr>
<tr class="separator:aec5ecb7f12940ba9db9f0633717c6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af737e054dda2d8cc062e45c288304b6e" id="r_af737e054dda2d8cc062e45c288304b6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#af737e054dda2d8cc062e45c288304b6e">countFileLines</a> (const std::string &amp;filePath)</td></tr>
<tr class="separator:af737e054dda2d8cc062e45c288304b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383ce9fb993729b272b68f339add44b1" id="r_a383ce9fb993729b272b68f339add44b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a383ce9fb993729b272b68f339add44b1">wrapToWidth</a> (std::string str, int wrapWidth)</td></tr>
<tr class="separator:a383ce9fb993729b272b68f339add44b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dad767a021dfb6ace7fa3788c20fab" id="r_a09dad767a021dfb6ace7fa3788c20fab"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a09dad767a021dfb6ace7fa3788c20fab">circularIndex</a> (std::string str, int circ_i)</td></tr>
<tr class="separator:a09dad767a021dfb6ace7fa3788c20fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7979bb34ee40190b84d9750f5a8c94" id="r_a7c7979bb34ee40190b84d9750f5a8c94"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a7c7979bb34ee40190b84d9750f5a8c94">eraseCharsFromEnd</a> (std::string str, int n)</td></tr>
<tr class="separator:a7c7979bb34ee40190b84d9750f5a8c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97f9b043053f16df01be3344e15ba1" id="r_aaa97f9b043053f16df01be3344e15ba1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#aaa97f9b043053f16df01be3344e15ba1">findAll</a> (std::string str, std::string substr)</td></tr>
<tr class="separator:aaa97f9b043053f16df01be3344e15ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc5f9915fcdea95ccd3536d77964b" id="r_a5bbbc5f9915fcdea95ccd3536d77964b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a5bbbc5f9915fcdea95ccd3536d77964b">getWhitespaceString</a> (const std::locale &amp;loc)</td></tr>
<tr class="separator:a5bbbc5f9915fcdea95ccd3536d77964b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78a2a94e837596ce18dfb92282b0ea5" id="r_aa78a2a94e837596ce18dfb92282b0ea5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#aa78a2a94e837596ce18dfb92282b0ea5">trimWhitespace</a> (std::string str)</td></tr>
<tr class="separator:aa78a2a94e837596ce18dfb92282b0ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9031d37220df1c65182f588a9e1e998c" id="r_a9031d37220df1c65182f588a9e1e998c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a9031d37220df1c65182f588a9e1e998c">char_to_string</a> (const char &amp;c)</td></tr>
<tr class="separator:a9031d37220df1c65182f588a9e1e998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc5a8eb271c99ac169ef509a7faeecb" id="r_a9fc5a8eb271c99ac169ef509a7faeecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a9fc5a8eb271c99ac169ef509a7faeecb">isNotDigit</a> (const char &amp;c)</td></tr>
<tr class="separator:a9fc5a8eb271c99ac169ef509a7faeecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac70294354fd548c0fcc74c31f3b924" id="r_aaac70294354fd548c0fcc74c31f3b924"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#aaac70294354fd548c0fcc74c31f3b924">eraseNonNumericChars</a> (std::string str)</td></tr>
<tr class="separator:aaac70294354fd548c0fcc74c31f3b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69119030f08c04d17f5ec4c59c0a8b6" id="r_ac69119030f08c04d17f5ec4c59c0a8b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#ac69119030f08c04d17f5ec4c59c0a8b6">reverse</a> (std::string str)</td></tr>
<tr class="separator:ac69119030f08c04d17f5ec4c59c0a8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc7a7ba1770dbc595aa351f8137bb4e" id="r_a3dc7a7ba1770dbc595aa351f8137bb4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestevensStringLib.html#a3dc7a7ba1770dbc595aa351f8137bb4e">isPalindrome</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a3dc7a7ba1770dbc595aa351f8137bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="stevensStringLib_8h_source.html">stevensStringLib.h</a></p>
<p>Defines the <a class="el" href="namespacestevensStringLib.html">stevensStringLib</a> namespace, a library meant to provide useful functions to expand interactions with the standard string type. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a34011fafa3843edec6ee27c5ad6dcf95" name="a34011fafa3843edec6ee27c5ad6dcf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34011fafa3843edec6ee27c5ad6dcf95">&#9670;&#160;</a></span>bool_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::bool_to_string </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a boolean value to a string value.</p>
<p>Taken from OJ's answer here: <a href="https://stackoverflow.com/questions/29383/converting-bool-to-text-in-c">https://stackoverflow.com/questions/29383/converting-bool-to-text-in-c</a></p>
<p>Parameter: bool input - The boolean value we wish to convert to a string.</p>
<p>Returns std::string - The boolean value represented as a string. </p>

</div>
</div>
<a id="a616701916cbe9be295361a93b7755f06" name="a616701916cbe9be295361a93b7755f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616701916cbe9be295361a93b7755f06">&#9670;&#160;</a></span>cap1stChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::cap1stChar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string with the first letter capitalized. If the string is empty, then we just return the empty string.</p>
<p>Parameter: std::string input - The string we want to capitalize the first letter of.</p>
<p>Returns: std::string - The input string with the first letter capitalized. </p>

</div>
</div>
<a id="a9031d37220df1c65182f588a9e1e998c" name="a9031d37220df1c65182f588a9e1e998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9031d37220df1c65182f588a9e1e998c">&#9670;&#160;</a></span>char_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::char_to_string </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a character c, convert it to a std::string.</p>
<p>Parameter: char c - The character we'd like to convert to a string.</p>
<p>Returns: std::string - A string representing the character c. </p>

</div>
</div>
<a id="a09dad767a021dfb6ace7fa3788c20fab" name="a09dad767a021dfb6ace7fa3788c20fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dad767a021dfb6ace7fa3788c20fab">&#9670;&#160;</a></span>circularIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char stevensStringLib::circularIndex </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>circ_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string an an integer representing an index, return a single character from the string by the process of circular indexing.</p>
<p>Circular indexing is performed by indexing over the string from left to right. Once the index exceeds the length of the string, we begin indexing again from the lefthand side of the string and repeat the process until we stop at the final index. We return the character at that final index.</p>
<p>Example: circularIndex("Hello world!", 13) returns 'e', as we loop around to 'H' at 12 and index one space further to reach 'e'.</p>
<p>Parameters: std::string str int circ_i</p>
<p>Returns: char - A character found in str that has been circularly indexed to at position circ_i</p>
<p>TODO: Create aliases ci and circ_i </p>

</div>
</div>
<a id="a86fbb60ec5f626744264a2e0ab5066a9" name="a86fbb60ec5f626744264a2e0ab5066a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fbb60ec5f626744264a2e0ab5066a9">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, determine whether it has an occurrence of the substring somewhere within it.</p>
<p>Parameters: const std::string &amp; str - The string we are examining to see if it contains the substring. const std::string &amp; substring - The substring we are trying to see if it is contained in str.</p>
<p>Returns: bool - Boolean indicating that input string contains the substring (true) or not (false). </p>

</div>
</div>
<a id="af737e054dda2d8cc062e45c288304b6e" name="af737e054dda2d8cc062e45c288304b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af737e054dda2d8cc062e45c288304b6e">&#9670;&#160;</a></span>countFileLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stevensStringLib::countFileLines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the path to a file, count how many lines are in the file and return the integer count.</p>
<p>Parameter: std::string filePath - The path to the file we want to count the number of lines of.</p>
<p>Returns: int - The integer number of lines that the file contains. </p>

</div>
</div>
<a id="aec5ecb7f12940ba9db9f0633717c6304" name="aec5ecb7f12940ba9db9f0633717c6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5ecb7f12940ba9db9f0633717c6304">&#9670;&#160;</a></span>countLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stevensStringLib::countLines </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, count how many lines are in that string and return the integer count. Solution from: <a href="https://stackoverflow.com/questions/3482064/counting-the-number-of-lines-in-a-text-file">https://stackoverflow.com/questions/3482064/counting-the-number-of-lines-in-a-text-file</a></p>
<p>TODO: Concerned with line counting problems presented here: <a href="https://stackoverflow.com/a/843484/16511184">https://stackoverflow.com/a/843484/16511184</a></p>
<p>Parameter: std::string str - The string which we wish to count the number of lines of.</p>
<p>Returns: int - The integer count of the number of lines that the string str has. </p>

</div>
</div>
<a id="a7c7979bb34ee40190b84d9750f5a8c94" name="a7c7979bb34ee40190b84d9750f5a8c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7979bb34ee40190b84d9750f5a8c94">&#9670;&#160;</a></span>eraseCharsFromEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseCharsFromEnd </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string str, erase the last n characters of the string.</p>
<p>Taken from: <a href="https://thispointer.com/remove-last-n-characters-from-a-string-in-c/">https://thispointer.com/remove-last-n-characters-from-a-string-in-c/</a></p>
<p>Parameters: std::string str - The string we want to erase characters from the end of. int n - The number of characters we want to erase</p>
<p>Returns: std::string - The string str having n characters erased from the end of it. </p>

</div>
</div>
<a id="aaac70294354fd548c0fcc74c31f3b924" name="aaac70294354fd548c0fcc74c31f3b924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac70294354fd548c0fcc74c31f3b924">&#9670;&#160;</a></span>eraseNonNumericChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::eraseNonNumericChars </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases all non-numeric characters from a string and returns it.</p>
<p>Parameter: std::string str - The string to release all non-numeric chars from.</p>
<p>Returns: The string parameter we passed in, but all of its non-numeric characters removed from it. </p>

</div>
</div>
<a id="aaa97f9b043053f16df01be3344e15ba1" name="aaa97f9b043053f16df01be3344e15ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97f9b043053f16df01be3344e15ba1">&#9670;&#160;</a></span>findAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; stevensStringLib::findAll </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string str, find all occurrences of a substring within it. Returns a vector of all of the indices that the substring occurs at within the string str.</p>
<p>Based off of: <a href="https://stackoverflow.com/a/4034809">https://stackoverflow.com/a/4034809</a></p>
<p>Parameters: std::string str - The string we are searching for the substring in. std::string substr - The substring we are looking for within string str.</p>
<p>Returns: std::vector&lt;size_t&gt; - A vector containing all indices in increasing order that the substr occurs at. </p>

</div>
</div>
<a id="a5bbbc5f9915fcdea95ccd3536d77964b" name="a5bbbc5f9915fcdea95ccd3536d77964b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbc5f9915fcdea95ccd3536d77964b">&#9670;&#160;</a></span>getWhitespaceString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::getWhitespaceString </td>
          <td>(</td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a locale, return all of the whitespace characters for that locale in a string.</p>
<p>Credit: <a href="https://stackoverflow.com/a/36311304/16511184">https://stackoverflow.com/a/36311304/16511184</a></p>
<p>Parameter: const std::locale &amp; loc - The locale which we want to obtain a string of all whitespace characters for.</p>
<p>Returns: std::string - A string of all whitespace characters defined in the given locale. </p>

</div>
</div>
<a id="a31ee6720d9d0028eb7891e9360b6c68a" name="a31ee6720d9d0028eb7891e9360b6c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ee6720d9d0028eb7891e9360b6c68a">&#9670;&#160;</a></span>isFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects if a string is in the form of a valid c++ floating point number.</p>
<p>Parameter: const std::string &amp; str - A string we are checking to see if it represents a floating point number.</p>
<p>Returns: bool - true if the string str represents a floating point number. False otherwise. </p>

</div>
</div>
<a id="a734c980bfd536f7929cd051283ea192c" name="a734c980bfd536f7929cd051283ea192c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734c980bfd536f7929cd051283ea192c">&#9670;&#160;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isInteger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects if a string is in the form of a valid C++ integer.</p>
<p>Parameter: const std::string &amp; str - A string we are checking to see if it represents an integer.</p>
<p>Returns: bool - true if the string str represents an integer, false otherwise. </p>

</div>
</div>
<a id="a9fc5a8eb271c99ac169ef509a7faeecb" name="a9fc5a8eb271c99ac169ef509a7faeecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc5a8eb271c99ac169ef509a7faeecb">&#9670;&#160;</a></span>isNotDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isNotDigit </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predicate function for eraseNonNumericChars. It performs a logical not operation on the result of the isdigit() function.</p>
<p>Parameter: const char &amp; c - The character we'd like to check to see if it is not a digit.</p>
<p>Returns: bool - True if c is not a digit, false otherwise. </p>

</div>
</div>
<a id="a72692e6b9776275f737e5087ee1b87cb" name="a72692e6b9776275f737e5087ee1b87cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72692e6b9776275f737e5087ee1b87cb">&#9670;&#160;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects whether or not the user input is in the form of an integer or floating point number. Does not work for mathematical expressions!</p>
<p>Parameter: const std::string &amp; str - The string we are checking to see if it represents a number. Returns: bool - True if the string represents a number. False if otherwise. </p>

</div>
</div>
<a id="a3dc7a7ba1770dbc595aa351f8137bb4e" name="a3dc7a7ba1770dbc595aa351f8137bb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc7a7ba1770dbc595aa351f8137bb4e">&#9670;&#160;</a></span>isPalindrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::isPalindrome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if a std::string is a palindrime or not (the reversed order of characters equals the original order of characters). Note well that character case, spacing, and punctuation present in classic English palindromes like "A man, a plan, a canal, panama" prevent them from being valid C++ palindromes with this function, as the reverse order of this exact string is "amanap ,lanac a ,nalp a ,nam A" is not equivalent to the original order of characters.</p>
<p>Credit: <a href="https://stackoverflow.com/a/8362657/16511184">https://stackoverflow.com/a/8362657/16511184</a></p>
<p>Parameter: std::string str - The string we would like to check.</p>
<p>Returns: bool - true if str is a palindrome, false otherwise. </p>

</div>
</div>
<a id="a2c3c2bc3c3c819fbc8d8e8de6a3d8423" name="a2c3c2bc3c3c819fbc8d8e8de6a3d8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3c2bc3c3c819fbc8d8e8de6a3d8423">&#9670;&#160;</a></span>mapifyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; stevensStringLib::mapifyString </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pairSeparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreWhitespace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: Make one mapify function for std::map and std::unordered_map. This can be done with templates, somehow. Need to do research.</p>
<p>Given an input string str that can represent a map, take two separator strings and separate the pairs from eachother, and they keys and values from each other. Then insert each key value pair into a std::map&lt;std::string,std::string&gt; object. </p>

</div>
</div>
<a id="acc289dc431709640aac960c1322f4278" name="acc289dc431709640aac960c1322f4278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc289dc431709640aac960c1322f4278">&#9670;&#160;</a></span>removeWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::removeWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all tabs, spaces, newlines, and anything else from a string that is defined as whitespace in the current locale.</p>
<p>Learn what is defined as whitespace: <a href="https://en.cppreference.com/w/cpp/string/byte/isspace">https://en.cppreference.com/w/cpp/string/byte/isspace</a> Solution from Michael Steller: <a href="https://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c">https://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c</a></p>
<p>Paraemter: std::string str - The string from which we wish to remove all the whitespace from.</p>
<p>Returns: std::string - The input string but with all of the whitespace removed </p>

</div>
</div>
<a id="ac69119030f08c04d17f5ec4c59c0a8b6" name="ac69119030f08c04d17f5ec4c59c0a8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69119030f08c04d17f5ec4c59c0a8b6">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::reverse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverses the order of a string's characters using std::reverse().</p>
<p>Parameter: std::string &amp; str - The string we would like to reverse.</p>
<p>Returns: std::string - The reversed string. </p>

</div>
</div>
<a id="ae75dd17730068a151f3f34d299cfb7fa" name="ae75dd17730068a151f3f34d299cfb7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75dd17730068a151f3f34d299cfb7fa">&#9670;&#160;</a></span>separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; stevensStringLib::separate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>omitEmptyStrings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Separates a string by a separator substring. Returns a vector of strings that were separated by the separator substring.</p>
<p>Example: std::vector&lt;std::string&gt; result = separate( "John,Gina,Sebastian,Nick", ",")</p>
<p>//Value of result is: {"John","Gina","Sebastian","Nick"} @ </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The string we intend to separate with this function. </td></tr>
    <tr><td class="paramname">separator</td><td>- The substring of str we intend to separate it by. </td></tr>
    <tr><td class="paramname">omitEmptyStrings</td><td>- If true, do not include empty strings in the returned vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">vector&lt;std::string&gt;</td><td>- A vector of substrings of the original string that have been split up by all occurrences of the separator parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bcc004e8edffbe6db42387a957a3c1b" name="a1bcc004e8edffbe6db42387a957a3c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcc004e8edffbe6db42387a957a3c1b">&#9670;&#160;</a></span>string_to_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stevensStringLib::string_to_bool </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a string and checks to see if it is a representation of the word "true" or "0". In those cases, return a true bool. In all other cases, return false.</p>
<p>Parameter: std::string input - A string we are converting to a bool.</p>
<p>Returns: bool - True if the input is a form of the word true or 0, and false otherwise. </p>

</div>
</div>
<a id="a810d50a0e7386192bd72a28dbdd3985b" name="a810d50a0e7386192bd72a28dbdd3985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810d50a0e7386192bd72a28dbdd3985b">&#9670;&#160;</a></span>stringifyUnordered_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::stringifyUnordered_map </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt;&#160;</td>
          <td class="paramname"><em>umap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an unordered_map of strings, turn it into a string of keys and values paired together separated by delimiting characters.</p>
<p>Parameters: unordered_map&lt;std::string,std::string&gt; umap - The unordered map with string keys and values which we intend to turn into a string. std::string keyValueSeparator - The string that separates keys from their values in the returned string. std::string pairSeparator - The string that separates key-value pairs in the returned string.</p>
<p>Returns: std::string - The all contents of the unordered map turned into a string list of separated key-value pairs. </p>

</div>
</div>
<a id="a7c1197f49a832b1beab045ad096c2758" name="a7c1197f49a832b1beab045ad096c2758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1197f49a832b1beab045ad096c2758">&#9670;&#160;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::toUpper </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a string with all characters in uppercase if possible.

Credit to this article: https://www.geeksforgeeks.org/conversion-whole-string-uppercase-lowercase-using-stl-c/
</pre><p> Parameters: std::string &amp; str - The string we would like to make all uppercase.</p>
<p>Returns: std::string - The parameter str, but all in uppercase!</p>
<p>` </p>

</div>
</div>
<a id="a673dffa5269fea2d342f27372c68f9e5" name="a673dffa5269fea2d342f27372c68f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673dffa5269fea2d342f27372c68f9e5">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>charsToTrim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string and integer X, erase (trim) X characters from both the beginning and end of the string.</p>
<p>Parameters: std::string input - A string we would like to trim the characters from. const int &amp; charsToTrim - The number of characters to trim from the beginning and end of the string.</p>
<p>Returns: std::string - A modified version of the input string, with X characters from both the beginning and end of the string trimmed off. </p>

</div>
</div>
<a id="aa78a2a94e837596ce18dfb92282b0ea5" name="aa78a2a94e837596ce18dfb92282b0ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78a2a94e837596ce18dfb92282b0ea5">&#9670;&#160;</a></span>trimWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::trimWhitespace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all leading and trailing whitespace from a string (spaces, tabs, newlines, etc.), then return it.</p>
<p>Based on: <a href="https://stackoverflow.com/a/1798170">https://stackoverflow.com/a/1798170</a></p>
<p>Parameter: std::string str - The string to remove all of the leading and trailing whitespaces from.</p>
<p>Returns: std::string - str modified by removing all of its leading and trailing whitespaces. </p>

</div>
</div>
<a id="a400139dff51fd0cad31ad2f0fcbc1274" name="a400139dff51fd0cad31ad2f0fcbc1274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400139dff51fd0cad31ad2f0fcbc1274">&#9670;&#160;</a></span>unordered_mapifyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::string &gt; stevensStringLib::unordered_mapifyString </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>keyValueSeparator</em> = <code>&quot;:&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pairSeparator</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreWhitespace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an input string str that can represent a map, take two separator strings and separate the pairs from eachother, and they keys and values from each other. Then insert each key value pair into a std::map&lt;std::string,std::string&gt; object. </p>

</div>
</div>
<a id="a383ce9fb993729b272b68f339add44b1" name="a383ce9fb993729b272b68f339add44b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383ce9fb993729b272b68f339add44b1">&#9670;&#160;</a></span>wrapToWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string stevensStringLib::wrapToWidth </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrapWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string and integer describing the total number of characters that can exist in a line of text, wrap the text by adding newlines between words so it may fit within a certain width.</p>
<p>Parameters: std::string str - The string which we wish to wrap to a certain width. int wrapWidth - The width in number of characters we wish to wrap.</p>
<p>Returns: std::string - A modified version of the parameter str, with newlines added to it so that it fits within a certain character width. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
